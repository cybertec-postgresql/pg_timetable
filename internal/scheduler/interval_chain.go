package scheduler

import (
	"context"
	"time"

	"github.com/cybertec-postgresql/pg_timetable/internal/log"
)

// IntervalChain structure used to represent repeated chains.
type IntervalChain struct {
	Chain
	Interval    int  `db:"interval_seconds"`
	RepeatAfter bool `db:"repeat_after"`
}

func (ichain IntervalChain) isListed(ichains []IntervalChain) bool {
	for _, ic := range ichains {
		if ichain.ChainExecutionConfigID == ic.ChainExecutionConfigID {
			return true
		}
	}
	return false
}

func (sch *Scheduler) isValid(ichain IntervalChain) bool {
	return (IntervalChain{}) != sch.intervalChains[ichain.ChainExecutionConfigID]
}

func (sch *Scheduler) reschedule(ctx context.Context, ichain IntervalChain) {
	if ichain.SelfDestruct {
		sch.pgengine.DeleteChainConfig(ctx, ichain.ChainExecutionConfigID)
		return
	}
	log.GetLogger(ctx).Debug("Sleeping before next execution of interval chain")
	select {
	case <-time.After(time.Duration(ichain.Interval) * time.Second):
		if sch.isValid(ichain) {
			sch.intervalChainsChan <- ichain
		}
	case <-ctx.Done():
		return
	}
}

func (sch *Scheduler) retrieveIntervalChainsAndRun(ctx context.Context) {
	sch.intervalChainMutex.Lock()
	ichains := []IntervalChain{}
	err := sch.pgengine.SelectIntervalChains(ctx, &ichains)
	if err != nil {
		sch.l.WithError(err).Error("Could not query pending interval tasks")
	} else {
		sch.l.WithField("count", len(ichains)).Info("Retrieve interval chains to run")
	}

	// delete chains that are not returned from the database
	for id, ichain := range sch.intervalChains {
		if !ichain.isListed(ichains) {
			delete(sch.intervalChains, id)
		}
	}

	// update chains from the database and send to working channel new one
	for _, ichain := range ichains {
		if (IntervalChain{}) == sch.intervalChains[ichain.ChainExecutionConfigID] {
			sch.intervalChainsChan <- ichain
		}
		sch.intervalChains[ichain.ChainExecutionConfigID] = ichain
	}
	sch.intervalChainMutex.Unlock()
}

func (sch *Scheduler) intervalChainWorker(ctx context.Context, ichains <-chan IntervalChain) {
	for {
		select {
		case <-ctx.Done(): //check context with high priority
			return
		default:
			select {
			case ichain := <-ichains:
				if !sch.isValid(ichain) { // chain not in the list of active chains
					continue
				}
				chainL := sch.l.WithField("chain", ichain.ChainExecutionConfigID)
				chainContext := log.WithLogger(ctx, chainL)
				chainL.Info("Starting chain")
				if !ichain.RepeatAfter {
					go sch.reschedule(chainContext, ichain)
				}
				if !sch.pgengine.CanProceedChainExecution(chainContext, ichain.ChainExecutionConfigID, ichain.MaxInstances) {
					chainL.Debug("Cannot proceed. Sleeping")
					if ichain.RepeatAfter {
						go sch.reschedule(chainContext, ichain)
					}
					continue
				}
				sch.Lock(ichain.ExclusiveExecution)
				sch.executeChain(chainContext, ichain.ChainExecutionConfigID, ichain.ChainID)
				sch.Unlock(ichain.ExclusiveExecution)
				if ichain.RepeatAfter {
					go sch.reschedule(chainContext, ichain)
				}
			case <-ctx.Done():
				return
			}
		}
	}
}
