{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>pg_timetable is an advanced job scheduler for PostgreSQL, offering many advantages over traditional schedulers such as cron and others. It is completely database driven and provides a couple of advanced concepts.</p>"},{"location":"#main-features","title":"Main features","text":"<ul> <li>Tasks can be arranged in chains</li> <li>A chain can consist of built-int commands, SQL and executables</li> <li>Parameters can be passed to chains</li> <li>Missed tasks (possibly due to downtime) can be retried automatically</li> <li>Support for configurable repetitions</li> <li>Built-in tasks such as sending emails, etc.</li> <li>Fully database driven configuration</li> <li>Full support for database driven logging</li> <li>Cron-style scheduling at the PostgreSQL server time zone</li> <li>Optional concurrency protection</li> <li>Task and chain can have execution timeout settings</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Download pg_timetable executable</li> <li> <p>Make sure your PostgreSQL server is up and running and has a role with <code>CREATE</code> privilege     for a target database, e.g.</p> <pre><code>my_database=&gt; CREATE ROLE scheduler PASSWORD 'somestrong';\nmy_database=&gt; GRANT CREATE ON DATABASE my_database TO scheduler;\n</code></pre> </li> <li> <p>Create a new job, e.g. run <code>VACUUM</code> each night at 00:30 Postgres server time zone</p> <pre><code>my_database=&gt; SELECT timetable.add_job('frequent-vacuum', '30 * * * *', 'VACUUM');\nadd_job\n---------\n      3\n(1 row)\n</code></pre> </li> <li> <p>Run the pg_timetable</p> <pre><code># pg_timetable postgresql://scheduler:somestrong@localhost/my_database --clientname=vacuumer\n</code></pre> </li> <li> <p>PROFIT!</p> </li> </ol>"},{"location":"#command-line-options","title":"Command line options","text":"<pre><code># ./pg_timetable\n\nApplication Options:\n  -c, --clientname=                                Unique name for application instance [$PGTT_CLIENTNAME]\n      --config=                                    YAML configuration file\n      --no-program-tasks                           Disable executing of PROGRAM tasks [$PGTT_NOPROGRAMTASKS]\n  -v, --version                                    Output detailed version information [$PGTT_VERSION]\n      --connstr                                    PostgreSQL connection string [$PGTT_CONNSTR]\n\nLogging:\n      --log-level=[debug|info|error]               Verbosity level for stdout and log file (default: info)\n      --log-database-level=[debug|info|error|none] Verbosity level for database storing (default: info)\n      --log-file=                                  File name to store logs\n      --log-file-format=[json|text]                Format of file logs (default: json)\n      --log-file-rotate                            Rotate log files\n      --log-file-size=                             Maximum size in MB of the log file before it gets rotated (default: 100)\n      --log-file-age=                              Number of days to retain old log files, 0 means forever (default: 0)\n      --log-file-number=                           Maximum number of old log files to retain, 0 to retain all (default: 0)\n\nStart:\n  -f, --file=                                      SQL script file to execute during startup\n      --init                                       Initialize database schema to the latest version and exit. Can be used\n                                                   with --upgrade\n      --upgrade                                    Upgrade database to the latest version\n      --debug                                      Run in debug mode. Only asynchronous chains will be executed\n\nResource:\n      --cron-workers=                              Number of parallel workers for scheduled chains (default: 16)\n      --interval-workers=                          Number of parallel workers for interval chains (default: 16)\n      --chain-timeout=                             Abort any chain that takes more than the specified number of\n                                                   milliseconds\n      --task-timeout=                              Abort any task within a chain that takes more than the specified number\n                                                   of milliseconds\n\nREST:\n      --rest-port=                                 REST API port (default: 0) [$PGTT_RESTPORT]\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to contribute to pg_timetable and help make it better, feel free to open an  issue or even consider submitting a  pull request. You also can give a  star to pg_timetable project,  and to tell the world about it.</p>"},{"location":"#support","title":"Support","text":"<p>For professional support, please contact Cybertec.</p>"},{"location":"#authors","title":"Authors","text":"<p>Implementation: Pavlo Golub </p> <p>Initial idea and draft design: Hans-J\u00fcrgen Sch\u00f6nig</p>"},{"location":"api/","title":"REST API","text":"<p>pg_timetable has a rich REST API, which can be used by external tools in order to perform start/stop/reinitialize/restarts/reloads,  by any kind of tools to perform HTTP health checks, and of course, could also be used for monitoring.</p> <p>Below you will find the list of pg_timetable REST API endpoints.</p>"},{"location":"api/#health-check-endpoints","title":"Health check endpoints","text":""},{"location":"api/#get-liveness","title":"<code>GET /liveness</code>","text":"<p>Always returns HTTP status code <code>200</code>, indicating that pg_timetable is running.</p>"},{"location":"api/#get-readiness","title":"<code>GET /readiness</code>","text":"<p>Returns HTTP status code <code>200</code> when the pg_timetable is running, and the scheduler is in the main loop processing chains.  If the scheduler connects to the database, creates the database schema, or upgrades it, it will return the HTTP status code <code>503</code>.</p>"},{"location":"api/#chain-management-endpoints","title":"Chain management endpoints","text":""},{"location":"api/#get-startchainidchain-id","title":"<code>GET /startchain?id=&lt;chain-id&gt;</code>","text":"<p>Returns HTTP status code <code>200</code> if the chain with the given id can be added to the worker queue. It doesn't, however, mean the chain execution starts immediately. It is up to the worker to perform load and other checks before starting the chain. In the case of an error, the HTTP status code <code>400</code> followed by an error message returned.</p>"},{"location":"api/#get-stopchainidchain-id","title":"<code>GET /stopchain?id=&lt;chain-id&gt;</code>","text":"<p>Returns HTTP status code <code>200</code> if the chain with the given id is working at the moment and can be stopped. If the chain is running the cancel signal would be sent immediately. In the case of an error, the HTTP status code <code>400</code> followed by an error message returned.</p>"},{"location":"background/","title":"Project background","text":"<p>The pg_timetable project got started back in 2019 for internal scheduling needs at Cybertec.</p> <p>For more background on the project motivations and design goals see the original series of blogposts announcing the project and the following feature updates.</p> <p>Cybertec also provides commercial 9-to-5 and 24/7 support for pg_timetable.</p> <ul> <li> <p>Project announcement</p> </li> <li> <p>v2 released</p> </li> <li> <p>Start-up improvements</p> </li> <li> <p>v3 released</p> </li> <li> <p>Exclusive jobs explained</p> </li> <li> <p>Asynchronous chain execution</p> </li> <li> <p>v4 released</p> </li> <li> <p>PostgreSQL schedulers: comparison table</p> </li> </ul>"},{"location":"background/#project-feedback","title":"Project feedback","text":"<p>For feature requests or troubleshooting assistance please open an issue on project's Github page.</p>"},{"location":"basic_jobs/","title":"Getting started","text":"<p>A variety of examples can be found in the samples. If you want to migrate from a different scheduler, you can use scripts from migration chapter.</p>"},{"location":"basic_jobs/#add-simple-job","title":"Add simple job","text":"<p>In a real world usually it's enough to use simple jobs. Under this term we understand:</p> <ul> <li>job is a chain with only one task (step) in it;</li> <li>it doesn't use complicated logic, but rather simple command;</li> <li>it doesn't require complex transaction handling, since one task is implicitely executed as a single transaction.</li> </ul> <p>For such a group of chains we've introduced a special function <code>timetable.add_job()</code>.</p>"},{"location":"basic_jobs/#function-timetableadd_job","title":"Function: <code>timetable.add_job()</code>","text":"<p>Creates a simple one-task chain</p> <p>Returns: <code>BIGINT</code></p>"},{"location":"basic_jobs/#parameters","title":"Parameters","text":"Parameter Type Description Default <code>job_name</code> <code>text</code> The unique name of the chain and command Required <code>job_schedule</code> <code>timetable.cron</code> Time schedule in \u0441ron syntax at Postgres server time zone Required <code>job_command</code> <code>text</code> The SQL which will be executed Required <code>job_parameters</code> <code>jsonb</code> Arguments for the chain command <code>NULL</code> <code>job_kind</code> <code>timetable.command_kind</code> Kind of the command: SQL, PROGRAM or BUILTIN <code>SQL</code> <code>job_client_name</code> <code>text</code> Specifies which client should execute the chain. Set this to <code>NULL</code> to allow any client <code>NULL</code> <code>job_max_instances</code> <code>integer</code> The amount of instances that this chain may have running at the same time <code>NULL</code> <code>job_live</code> <code>boolean</code> Control if the chain may be executed once it reaches its schedule <code>TRUE</code> <code>job_self_destruct</code> <code>boolean</code> Self destruct the chain after execution <code>FALSE</code> <code>job_ignore_errors</code> <code>boolean</code> Ignore error during execution <code>TRUE</code> <code>job_exclusive</code> <code>boolean</code> Execute the chain in the exclusive mode <code>FALSE</code> <p>Returns: the ID of the created chain</p>"},{"location":"basic_jobs/#examples","title":"Examples","text":"<ol> <li> <p>Run <code>public.my_func()</code> at 00:05 every day in August Postgres server time zone:</p> <pre><code>SELECT timetable.add_job('execute-func', '5 0 * 8 *', 'SELECT public.my_func()');\n</code></pre> </li> <li> <p>Run <code>VACUUM</code> at minute 23 past every 2nd hour from 0 through 20 every day Postgres server time zone:</p> <pre><code>SELECT timetable.add_job('run-vacuum', '23 0-20/2 * * *', 'VACUUM');\n</code></pre> </li> <li> <p>Refresh materialized view every 2 hours:</p> <pre><code>SELECT timetable.add_job('refresh-matview', '@every 2 hours', 'REFRESH MATERIALIZED VIEW public.mat_view');\n</code></pre> </li> <li> <p>Clear log table after pg_timetable restart:</p> <pre><code>SELECT timetable.add_job('clear-log', '@reboot', 'TRUNCATE timetable.log');\n</code></pre> </li> <li> <p>Reindex at midnight Postgres server time zone on Sundays with reindexdb utility:</p> <ul> <li> <p>using default database under default user (no command line arguments)</p> <pre><code>SELECT timetable.add_job('reindex', '0 0 * * 7', 'reindexdb', job_kind := 'PROGRAM');\n</code></pre> </li> <li> <p>specifying target database and tables, and be verbose</p> <pre><code>SELECT timetable.add_job('reindex', '0 0 * * 7', 'reindexdb', \n    '[\"--table=foo\", \"--dbname=postgres\", \"--verbose\"]'::jsonb, 'PROGRAM');\n</code></pre> </li> <li> <p>passing password using environment variable through <code>bash</code> shell</p> <pre><code>SELECT timetable.add_job('reindex', '0 0 * * 7', 'bash', \n    '[\"-c\", \"PGPASSWORD=5m3R7K4754p4m reindexdb -U postgres -h 192.168.0.221 -v\"]'::jsonb, \n    'PROGRAM');\n</code></pre> </li> </ul> </li> </ol>"},{"location":"components/","title":"Components","text":"<p>The scheduling in pg_timetable encompasses three different abstraction levels to facilitate the reuse with other parameters or additional schedules.</p> <p>Command: The base level, command, defines what to do.</p> <p>Task: The second level, task, represents a chain element (step) to run one of the commands. With tasks we define order of commands, arguments passed (if any), and how errors are handled.</p> <p>Chain: The third level represents a connected tasks forming a chain of tasks. Chain defines if, when, and how often a job should be executed.</p>"},{"location":"components/#command","title":"Command","text":"<p>Currently, there are three different kinds of commands:</p>"},{"location":"components/#sql","title":"<code>SQL</code>","text":"<p>SQL snippet. Starting a cleanup, refreshing a materialized view or processing data.</p>"},{"location":"components/#program","title":"<code>PROGRAM</code>","text":"<p>External Command. Anything that can be called as an external binary, including shells, e.g. <code>bash</code>, <code>pwsh</code>, etc. The external command will be called using golang's exec.CommandContext.</p>"},{"location":"components/#builtin","title":"<code>BUILTIN</code>","text":"<p>Internal Command. A prebuilt functionality included in pg_timetable. These include:</p> <ul> <li>NoOp</li> <li>Sleep</li> <li>Log</li> <li>SendMail</li> <li>Download</li> <li>CopyFromFile</li> <li>CopyToFile</li> <li>Shutdown</li> </ul>"},{"location":"components/#task","title":"Task","text":"<p>The next building block is a task, which simply represents a step in a list of chain commands. An example of tasks combined in a chain would be:</p> <ol> <li>Download files from a server</li> <li>Import files</li> <li>Run aggregations</li> <li>Build report</li> <li>Remove the files from disk</li> </ol> <p>Note</p> <p>All tasks of the chain in pg_timetable are executed within one transaction. However, please, pay attention there is no opportunity to rollback <code>PROGRAM</code> and <code>BUILTIN</code> tasks.</p>"},{"location":"components/#table-timetabletask","title":"Table timetable.task","text":"Field Type Description <code>chain_id</code> <code>bigint</code> Link to the chain, if <code>NULL</code> task considered to be disabled <code>task_order</code> <code>DOUBLE PRECISION</code> Indicates the order of task within a chain <code>kind</code> <code>timetable.command_kind</code> The type of the command. Can be SQL (default), PROGRAM or BUILTIN <code>command</code> <code>text</code> Contains either a SQL command, a path to application or name of the BUILTIN command which will be executed <code>run_as</code> <code>text</code> The role as which the task should be executed as <code>database_connection</code> <code>text</code> The connection string for the external database that should be used <code>ignore_error</code> <code>boolean</code> Specify if the next task should proceed after encountering an error (default: <code>false</code>) <code>autonomous</code> <code>boolean</code> Specify if the task should be executed out of the chain transaction. Useful for <code>VACUUM</code>, <code>CREATE DATABASE</code>, <code>CALL</code> etc. <code>timeout</code> <code>integer</code> Abort any task within a chain that takes more than the specified number of milliseconds <p>Warning</p> <p>If the task has been configured with <code>ignore_error</code> set to <code>true</code> (the default value is <code>false</code>), the worker process will report a success on execution even if the task within the chain fails.</p> <p>As mentioned above, commands are simple skeletons (e.g. send email, vacuum, etc.). In most cases, they have to be brought to live by passing input parameters to the execution.</p>"},{"location":"components/#table-timetableparameter","title":"Table timetable.parameter","text":"Field Type Description <code>task_id</code> <code>bigint</code> The ID of the task <code>order_id</code> <code>integer</code> The order of the parameter. Several parameters are processed one by one according to the order <code>value</code> <code>jsonb</code> A JSON value containing the parameters"},{"location":"components/#parameter-value-format","title":"Parameter value format","text":"<p>Depending on the command kind argument can be represented by different JSON values.</p>"},{"location":"components/#sql_1","title":"<code>SQL</code>","text":"<p>Schema: <code>array</code></p> <p>Example: <pre><code>'[ \"one\", 2, 3.14, false ]'::jsonb\n</code></pre></p>"},{"location":"components/#program_1","title":"<code>PROGRAM</code>","text":"<p>Schema: <code>array of strings</code></p> <p>Example: <pre><code>'[\"-x\", \"Latin-ASCII\", \"-o\", \"orte_ansi.txt\", \"orte.txt\"]'::jsonb\n</code></pre></p>"},{"location":"components/#builtin-sleep","title":"<code>BUILTIN: Sleep</code>","text":"<p>Schema: <code>integer</code></p> <p>Example: <pre><code>'5' :: jsonb\n</code></pre></p>"},{"location":"components/#builtin-log","title":"<code>BUILTIN: Log</code>","text":"<p>Schema: <code>any</code></p> <p>Examples: <pre><code>'\"WARNING\"'::jsonb\n'{\"Status\": \"WARNING\"}'::jsonb\n</code></pre></p>"},{"location":"components/#builtin-sendmail","title":"<code>BUILTIN: SendMail</code>","text":"<p>Schema: <code>object</code></p> <p>Example: <pre><code>'{\n    \"username\":     \"user@example.com\",\n    \"password\":     \"password\",\n    \"serverhost\":   \"smtp.example.com\",\n    \"serverport\":   587,\n    \"senderaddr\":   \"user@example.com\",\n    \"ccaddr\":       [\"recipient_cc@example.com\"],\n    \"bccaddr\":      [\"recipient_bcc@example.com\"],\n    \"toaddr\":       [\"recipient@example.com\"],\n    \"subject\":      \"pg_timetable - No Reply\",\n    \"attachment\":   [\"/temp/attachments/Report.pdf\",\"config.yaml\"],\n    \"attachmentdata\": [{\"name\": \"File.txt\", \"base64data\": \"RmlsZSBDb250ZW50\"}],\n    \"msgbody\":      \"&lt;h2&gt;Hello User,&lt;/h2&gt; &lt;p&gt;check some attachments!&lt;/p&gt;\",\n    \"contenttype\":   \"text/html; charset=UTF-8\"\n}'::jsonb\n</code></pre></p>"},{"location":"components/#builtin-download","title":"<code>BUILTIN: Download</code>","text":"<p>Schema: <code>object</code></p> <p>Example: <pre><code>'{\n    \"workersnum\": 2, \n    \"fileurls\": [\"http://example.com/foo.gz\", \"https://example.com/bar.csv\"], \n    \"destpath\": \".\"\n}'::jsonb\n</code></pre></p>"},{"location":"components/#builtin-copyfromfile","title":"<code>BUILTIN: CopyFromFile</code>","text":"<p>Schema: <code>object</code></p> <p>Example: <pre><code>'{\n    \"sql\": \"COPY location FROM STDIN\", \n    \"filename\": \"download/orte_ansi.txt\" \n}'::jsonb\n</code></pre></p>"},{"location":"components/#builtin-copytofile","title":"<code>BUILTIN: CopyToFile</code>","text":"<p>Schema: <code>object</code></p> <p>Example: <pre><code>'{\n    \"sql\": \"COPY location TO STDOUT\", \n    \"filename\": \"download/location.txt\" \n}'::jsonb\n</code></pre></p>"},{"location":"components/#builtin-shutdown","title":"<code>BUILTIN: Shutdown</code>","text":"<p>value ignored</p>"},{"location":"components/#builtin-noop","title":"<code>BUILTIN: NoOp</code>","text":"<p>value ignored</p>"},{"location":"components/#chain","title":"Chain","text":"<p>Once tasks have been arranged, they have to be scheduled as a chain. For this, pg_timetable builds upon the enhanced cron-string, all the while adding multiple configuration options.</p>"},{"location":"components/#table-timetablechain","title":"Table timetable.chain","text":"Field Type Description <code>chain_name</code> <code>text</code> The unique name of the chain <code>run_at</code> <code>timetable.cron</code> Standard cron-style value at Postgres server time zone or <code>@after</code>, <code>@every</code>, <code>@reboot</code> clause <code>max_instances</code> <code>integer</code> The amount of instances that this chain may have running at the same time <code>timeout</code> <code>integer</code> Abort any chain that takes more than the specified number of milliseconds <code>live</code> <code>boolean</code> Control if the chain may be executed once it reaches its schedule <code>self_destruct</code> <code>boolean</code> Self destruct the chain after successful execution. Failed chains will be executed according to the schedule one more time <code>exclusive_execution</code> <code>boolean</code> Specifies whether the chain should be executed exclusively while all other chains are paused <code>client_name</code> <code>text</code> Specifies which client should execute the chain. Set this to <code>NULL</code> to allow any client <code>timeout</code> <code>integer</code> Abort a chain that takes more than the specified number of milliseconds <code>on_error</code> \u2014 Holds SQL to execute if an error occurs. If task produced an error is marked with <code>ignore_error</code> then nothing is done <p>Note</p> <p>All chains in pg_timetable are scheduled at the PostgreSQL server time zone. You can change the timezone  for the current session when adding new chains, e.g.</p> <pre><code>SET TIME ZONE 'UTC';\n\n-- Run VACUUM at 00:05 every day in August UTC\nSELECT timetable.add_job('execute-func', '5 0 * 8 *', 'VACUUM');\n</code></pre>"},{"location":"database_schema/","title":"Database Schema","text":"<p>pg_timetable is a database driven application. During the first start the necessary schema is created if absent.</p>"},{"location":"database_schema/#main-tables-and-objects","title":"Main tables and objects","text":"<pre><code>CREATE TABLE timetable.chain (\n    chain_id            BIGSERIAL   PRIMARY KEY,\n    chain_name          TEXT        NOT NULL UNIQUE,\n    run_at              timetable.cron,\n    max_instances       INTEGER,\n    timeout             INTEGER     DEFAULT 0,\n    live                BOOLEAN     DEFAULT FALSE,\n    self_destruct       BOOLEAN     DEFAULT FALSE,\n    exclusive_execution BOOLEAN     DEFAULT FALSE,\n    client_name         TEXT,\n    on_error            TEXT\n);\n\nCOMMENT ON TABLE timetable.chain IS\n    'Stores information about chains schedule';\nCOMMENT ON COLUMN timetable.chain.run_at IS\n    'Extended CRON-style time notation the chain has to be run at';\nCOMMENT ON COLUMN timetable.chain.max_instances IS\n    'Number of instances (clients) this chain can run in parallel';\nCOMMENT ON COLUMN timetable.chain.timeout IS\n    'Abort any chain that takes more than the specified number of milliseconds';\nCOMMENT ON COLUMN timetable.chain.live IS\n    'Indication that the chain is ready to run, set to FALSE to pause execution';\nCOMMENT ON COLUMN timetable.chain.self_destruct IS\n    'Indication that this chain will delete itself after successful run';\nCOMMENT ON COLUMN timetable.chain.exclusive_execution IS\n    'All parallel chains should be paused while executing this chain';\nCOMMENT ON COLUMN timetable.chain.client_name IS\n    'Only client with this name is allowed to run this chain, set to NULL to allow any client';    \n\nCREATE TYPE timetable.command_kind AS ENUM ('SQL', 'PROGRAM', 'BUILTIN');\n\nCREATE TABLE timetable.task (\n    task_id             BIGSERIAL               PRIMARY KEY,\n    chain_id            BIGINT                  REFERENCES timetable.chain(chain_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    task_order          DOUBLE PRECISION        NOT NULL,\n    task_name           TEXT,\n    kind                timetable.command_kind  NOT NULL DEFAULT 'SQL',\n    command             TEXT                    NOT NULL,\n    run_as              TEXT,\n    database_connection TEXT,\n    ignore_error        BOOLEAN                 NOT NULL DEFAULT FALSE,\n    autonomous          BOOLEAN                 NOT NULL DEFAULT FALSE,\n    timeout             INTEGER                 DEFAULT 0\n);          \n\nCOMMENT ON TABLE timetable.task IS\n    'Holds information about chain elements aka tasks';\nCOMMENT ON COLUMN timetable.task.chain_id IS\n    'Link to the chain, if NULL task considered to be disabled';\nCOMMENT ON COLUMN timetable.task.task_order IS\n    'Indicates the order of task within a chain';    \nCOMMENT ON COLUMN timetable.task.run_as IS\n    'Role name to run task as. Uses SET ROLE for SQL commands';\nCOMMENT ON COLUMN timetable.task.ignore_error IS\n    'Indicates whether a next task in a chain can be executed regardless of the success of the current one';\nCOMMENT ON COLUMN timetable.task.kind IS\n    'Indicates whether \"command\" is SQL, built-in function or an external program';\nCOMMENT ON COLUMN timetable.task.command IS\n    'Contains either an SQL command, or command string to be executed';\nCOMMENT ON COLUMN timetable.task.timeout IS\n    'Abort any task within a chain that takes more than the specified number of milliseconds';\nCOMMENT ON COLUMN timetable.task.autonomous IS\n    'Specify if the task should be executed out of the chain transaction. Useful for VACUUM, CREATE DATABASE, CALL etc.';\n\n-- parameter passing for a chain task\nCREATE TABLE timetable.parameter(\n    task_id     BIGINT  REFERENCES timetable.task(task_id)\n                        ON UPDATE CASCADE ON DELETE CASCADE,\n    order_id    INTEGER CHECK (order_id &gt; 0),\n    value       JSONB,\n    PRIMARY KEY (task_id, order_id)\n);\n\nCOMMENT ON TABLE timetable.parameter IS\n    'Stores parameters passed as arguments to a chain task';\n\nCREATE UNLOGGED TABLE timetable.active_session(\n    client_pid  BIGINT  NOT NULL,\n    server_pid  BIGINT  NOT NULL,\n    client_name TEXT    NOT NULL,\n    started_at  TIMESTAMPTZ DEFAULT now()\n);\n\nCOMMENT ON TABLE timetable.active_session IS\n    'Stores information about active sessions';\n\nCREATE TYPE timetable.log_type AS ENUM ('DEBUG', 'NOTICE', 'INFO', 'ERROR', 'PANIC', 'USER');\n\nCREATE OR REPLACE FUNCTION timetable.get_client_name(integer) RETURNS TEXT AS\n$$\n    SELECT client_name FROM timetable.active_session WHERE server_pid = $1 LIMIT 1\n$$\nLANGUAGE sql;\n\nCREATE TABLE timetable.log\n(\n    ts              TIMESTAMPTZ         DEFAULT now(),\n    pid             INTEGER             NOT NULL,\n    log_level       timetable.log_type  NOT NULL,\n    client_name     TEXT                DEFAULT timetable.get_client_name(pg_backend_pid()),\n    message         TEXT,\n    message_data    jsonb\n);\n\nCOMMENT ON TABLE timetable.log IS\n    'Stores log entries of active sessions';\n\nCREATE TABLE timetable.execution_log (\n    chain_id        BIGINT,\n    task_id         BIGINT,\n    txid            BIGINT NOT NULL,\n    last_run        TIMESTAMPTZ DEFAULT now(),\n    finished        TIMESTAMPTZ,\n    pid             BIGINT,\n    returncode      INTEGER,\n    ignore_error    BOOLEAN,\n    kind            timetable.command_kind,\n    command         TEXT,\n    output          TEXT,\n    client_name     TEXT        NOT NULL\n);\n\nCOMMENT ON TABLE timetable.execution_log IS\n    'Stores log entries of executed tasks and chains';\n\nCREATE UNLOGGED TABLE timetable.active_chain(\n    chain_id    BIGINT  NOT NULL,\n    client_name TEXT    NOT NULL,\n    started_at  TIMESTAMPTZ DEFAULT now()\n);\n\nCOMMENT ON TABLE timetable.active_chain IS\n    'Stores information about active chains within session';\n\nCREATE OR REPLACE FUNCTION timetable.try_lock_client_name(worker_pid BIGINT, worker_name TEXT)\nRETURNS bool AS\n$CODE$\nBEGIN\n    IF pg_is_in_recovery() THEN\n        RAISE NOTICE 'Cannot obtain lock on a replica. Please, use the primary node';\n        RETURN FALSE;\n    END IF;\n    -- remove disconnected sessions\n    DELETE\n        FROM timetable.active_session\n        WHERE server_pid NOT IN (\n            SELECT pid\n            FROM pg_catalog.pg_stat_activity\n            WHERE application_name = 'pg_timetable'\n        );\n    DELETE \n        FROM timetable.active_chain \n        WHERE client_name NOT IN (\n            SELECT client_name FROM timetable.active_session\n        );\n    -- check if there any active sessions with the client name but different client pid\n    PERFORM 1\n        FROM timetable.active_session s\n        WHERE\n            s.client_pid &lt;&gt; worker_pid\n            AND s.client_name = worker_name\n        LIMIT 1;\n    IF FOUND THEN\n        RAISE NOTICE 'Another client is already connected to server with name: %', worker_name;\n        RETURN FALSE;\n    END IF;\n    -- insert current session information\n    INSERT INTO timetable.active_session(client_pid, client_name, server_pid) VALUES (worker_pid, worker_name, pg_backend_pid());\n    RETURN TRUE;\nEND;\n$CODE$\nSTRICT\nLANGUAGE plpgsql;\n</code></pre>"},{"location":"database_schema/#jobs-related-functions","title":"Jobs related functions","text":"<pre><code>-- add_task() will add a task to the same chain as the task with `parent_id`\nCREATE OR REPLACE FUNCTION timetable.add_task(\n    IN kind timetable.command_kind,\n    IN command TEXT, \n    IN parent_id BIGINT,\n    IN order_delta DOUBLE PRECISION DEFAULT 10\n) RETURNS BIGINT AS $$\n    INSERT INTO timetable.task (chain_id, task_order, kind, command) \n    SELECT chain_id, task_order + $4, $1, $2 FROM timetable.task WHERE task_id = $3\n    RETURNING task_id\n$$ LANGUAGE SQL;\n\nCOMMENT ON FUNCTION timetable.add_task IS 'Add a task to the same chain as the task with parent_id';\n\n-- add_job() will add one-task chain to the system\nCREATE OR REPLACE FUNCTION timetable.add_job(\n    job_name            TEXT,\n    job_schedule        timetable.cron,\n    job_command         TEXT,\n    job_parameters      JSONB DEFAULT NULL,\n    job_kind            timetable.command_kind DEFAULT 'SQL'::timetable.command_kind,\n    job_client_name     TEXT DEFAULT NULL,\n    job_max_instances   INTEGER DEFAULT NULL,\n    job_live            BOOLEAN DEFAULT TRUE,\n    job_self_destruct   BOOLEAN DEFAULT FALSE,\n    job_ignore_errors   BOOLEAN DEFAULT TRUE,\n    job_exclusive       BOOLEAN DEFAULT FALSE,\n    job_on_error        TEXT DEFAULT NULL\n) RETURNS BIGINT AS $$\n    WITH \n        cte_chain (v_chain_id) AS (\n            INSERT INTO timetable.chain (chain_name, run_at, max_instances, live, self_destruct, client_name, exclusive_execution, on_error) \n            VALUES (job_name, job_schedule,job_max_instances, job_live, job_self_destruct, job_client_name, job_exclusive, job_on_error)\n            RETURNING chain_id\n        ),\n        cte_task(v_task_id) AS (\n            INSERT INTO timetable.task (chain_id, task_order, kind, command, ignore_error, autonomous)\n            SELECT v_chain_id, 10, job_kind, job_command, job_ignore_errors, TRUE\n            FROM cte_chain\n            RETURNING task_id\n        ),\n        cte_param AS (\n            INSERT INTO timetable.parameter (task_id, order_id, value)\n            SELECT v_task_id, 1, job_parameters FROM cte_task, cte_chain\n        )\n        SELECT v_chain_id FROM cte_chain\n$$ LANGUAGE SQL;\n\nCOMMENT ON FUNCTION timetable.add_job IS 'Add one-task chain (aka job) to the system';\n\n-- notify_chain_start() will send notification to the worker to start the chain\nCREATE OR REPLACE FUNCTION timetable.notify_chain_start(\n    chain_id    BIGINT, \n    worker_name TEXT,\n    start_delay INTERVAL DEFAULT NULL\n) RETURNS void AS $$\n    SELECT pg_notify(\n        worker_name, \n        format('{\"ConfigID\": %s, \"Command\": \"START\", \"Ts\": %s, \"Delay\": %s}', \n            chain_id, \n            EXTRACT(epoch FROM clock_timestamp())::bigint,\n            COALESCE(EXTRACT(epoch FROM start_delay)::bigint, 0)\n        )\n    )\n$$ LANGUAGE SQL;\n\nCOMMENT ON FUNCTION timetable.notify_chain_start IS 'Send notification to the worker to start the chain';\n\n-- notify_chain_stop() will send notification to the worker to stop the chain\nCREATE OR REPLACE FUNCTION timetable.notify_chain_stop(\n    chain_id BIGINT, \n    worker_name TEXT\n) RETURNS void AS  $$ \n    SELECT pg_notify(\n        worker_name, \n        format('{\"ConfigID\": %s, \"Command\": \"STOP\", \"Ts\": %s}', \n            chain_id, \n            EXTRACT(epoch FROM clock_timestamp())::bigint)\n        )\n$$ LANGUAGE SQL;\n\nCOMMENT ON FUNCTION timetable.notify_chain_stop IS 'Send notification to the worker to stop the chain';\n\n-- move_task_up() will switch the order of the task execution with a previous task within the chain\nCREATE OR REPLACE FUNCTION timetable.move_task_up(IN task_id BIGINT) RETURNS boolean AS $$\n    WITH current_task (ct_chain_id, ct_id, ct_order) AS (\n        SELECT chain_id, task_id, task_order FROM timetable.task WHERE task_id = $1\n    ),\n    tasks(t_id, t_new_order) AS (\n        SELECT task_id, COALESCE(LAG(task_order) OVER w, LEAD(task_order) OVER w)\n        FROM timetable.task t, current_task ct\n        WHERE chain_id = ct_chain_id AND (task_order &lt; ct_order OR task_id = ct_id)\n        WINDOW w AS (PARTITION BY chain_id ORDER BY ABS(task_order - ct_order))\n        LIMIT 2\n    ),\n    upd AS (\n        UPDATE timetable.task t SET task_order = t_new_order\n        FROM tasks WHERE tasks.t_id = t.task_id AND tasks.t_new_order IS NOT NULL\n        RETURNING true\n    )\n    SELECT COUNT(*) &gt; 0 FROM upd\n$$ LANGUAGE SQL;\n\nCOMMENT ON FUNCTION timetable.move_task_up IS 'Switch the order of the task execution with a previous task within the chain';\n\n-- move_task_down() will switch the order of the task execution with a following task within the chain\nCREATE OR REPLACE FUNCTION timetable.move_task_down(IN task_id BIGINT) RETURNS boolean AS $$\n    WITH current_task (ct_chain_id, ct_id, ct_order) AS (\n        SELECT chain_id, task_id, task_order FROM timetable.task WHERE task_id = $1\n    ),\n    tasks(t_id, t_new_order) AS (\n        SELECT task_id, COALESCE(LAG(task_order) OVER w, LEAD(task_order) OVER w)\n        FROM timetable.task t, current_task ct\n        WHERE chain_id = ct_chain_id AND (task_order &gt; ct_order OR task_id = ct_id)\n        WINDOW w AS (PARTITION BY chain_id ORDER BY ABS(task_order - ct_order))\n        LIMIT 2\n    ),\n    upd AS (\n        UPDATE timetable.task t SET task_order = t_new_order\n        FROM tasks WHERE tasks.t_id = t.task_id AND tasks.t_new_order IS NOT NULL\n        RETURNING true\n    )\n    SELECT COUNT(*) &gt; 0 FROM upd\n$$ LANGUAGE SQL;\n\nCOMMENT ON FUNCTION timetable.move_task_down IS 'Switch the order of the task execution with a following task within the chain';\n\n-- delete_job() will delete the chain and its tasks from the system\nCREATE OR REPLACE FUNCTION timetable.delete_job(IN job_name TEXT) RETURNS boolean AS $$\n    WITH del_chain AS (DELETE FROM timetable.chain WHERE chain.chain_name = $1 RETURNING chain_id)\n    SELECT EXISTS(SELECT 1 FROM del_chain)\n$$ LANGUAGE SQL;\n\nCOMMENT ON FUNCTION timetable.delete_job IS 'Delete the chain and its tasks from the system';\n\n-- delete_task() will delete the task from a chain\nCREATE OR REPLACE FUNCTION timetable.delete_task(IN task_id BIGINT) RETURNS boolean AS $$\n    WITH del_task AS (DELETE FROM timetable.task WHERE task_id = $1 RETURNING task_id)\n    SELECT EXISTS(SELECT 1 FROM del_task)\n$$ LANGUAGE SQL;\n\nCOMMENT ON FUNCTION timetable.delete_task IS 'Delete the task from a chain';\n</code></pre>"},{"location":"database_schema/#ron-related-functions","title":"\u0421ron related functions","text":""},{"location":"database_schema/#er-diagram","title":"ER-Diagram","text":"<p>ER-Diagram showing the database structure</p>"},{"location":"installation/","title":"Installation","text":"<p>pg_timetable is compatible with the latest supported PostgreSQL versions: 11, 12, 13, 14 (stable); 15 (dev).</p> <p>Older PostgreSQL versions (9.5, 9.6, and 10)</p> <p>If you want to use pg_timetable with older versions (9.5, 9.6 and 10), please execute this SQL command before running pg_timetable:</p> <pre><code>CREATE OR REPLACE FUNCTION starts_with(text, text)\nRETURNS bool AS \n$$\nSELECT \n    CASE WHEN length($2) &gt; length($1) THEN \n        FALSE \n    ELSE \n        left($1, length($2)) = $2 \n    END\n$$\nLANGUAGE SQL\nIMMUTABLE STRICT PARALLEL SAFE\nCOST 5;\n</code></pre>"},{"location":"installation/#official-release-packages","title":"Official release packages","text":"<p>You may find binary package for your platform on the official Releases page. Right now Windows, Linux and macOS packages are available.</p>"},{"location":"installation/#docker","title":"Docker","text":"<p>The official docker image can be found here: https://hub.docker.com/r/cybertecpostgresql/pg_timetable</p> <p>Note</p> <p>The <code>latest</code> tag is up to date with the <code>master</code> branch thanks to this github action. In production you probably want to use the latest stable tag.</p> <p>Run pg_timetable in Docker:</p> <pre><code>docker run --rm \\\ncybertecpostgresql/pg_timetable:latest \\\n-h 10.0.0.3 -p 54321 -c worker001\n</code></pre> <p>Run pg_timetable in Docker with Environment variables:</p> <pre><code>docker run --rm \\\n-e PGTT_PGHOST=10.0.0.3 \\\n-e PGTT_PGPORT=54321 \\\ncybertecpostgresql/pg_timetable:latest \\\n-c worker001\n</code></pre>"},{"location":"installation/#build-from-sources","title":"Build from sources","text":"<ol> <li>Download and install Go on your system.</li> <li> <p>Clone pg_timetable repo:</p> <pre><code>$ git clone https://github.com/cybertec-postgresql/pg_timetable.git\n$ cd pg_timetable\n</code></pre> </li> <li> <p>Run pg_timetable:</p> <pre><code>$ go run main.go --clientname=worker001 postgresql://scheduler:strongpwd@localhost:5432/dbname\n</code></pre> </li> <li> <p>Alternatively, build a binary and run it:</p> <pre><code>$ go build\n$ ./pg_timetable --clientname=worker001 postgresql://scheduler:strongpwd@localhost:5432/dbname\n</code></pre> </li> <li> <p>(Optional) Run tests in all sub-folders of the project:</p> <pre><code>$ psql --command=\"CREATE USER scheduler PASSWORD 'somestrong'\"\n$ createdb --owner=scheduler timetable\n$ go test -failfast -timeout=300s -count=1 -p 1 ./...\n</code></pre> </li> </ol>"},{"location":"migration/","title":"Migration from others schedulers","text":""},{"location":"migration/#migrate-jobs-from-pg_cron-to-pg_timetable","title":"Migrate jobs from pg_cron to pg_timetable","text":"<p>If you want to quickly export jobs scheduled from pg_cron to pg_timetable, you can use this SQL snippet:</p> <pre><code>SELECT timetable.add_job(\n    job_name            =&gt; COALESCE(jobname, 'job: ' || command),\n    job_schedule        =&gt; schedule,\n    job_command         =&gt; command,\n    job_kind            =&gt; 'SQL',\n    job_live            =&gt; active\n) FROM cron.job;\n</code></pre> <p>The timetable.add_job(), however, has some limitations. First of all, the function will mark the task created  as autonomous, specifying scheduler should execute the task out of the chain transaction. It's not an error,  but many autonomous chains may cause some extra connections to be used.</p> <p>Secondly, database connection parameters are lost for source pg_cron jobs, making all jobs local. To export  every information available precisely as possible, use this SQL snippet under the role they were scheduled in  pg_cron:</p> <pre><code>SET ROLE 'scheduler'; -- set the role used by pg_cron\n\nWITH cron_chain AS (\n    SELECT\n        nextval('timetable.chain_chain_id_seq'::regclass) AS cron_id,\n        jobname,\n        schedule,\n        active,\n        command,\n        CASE WHEN \n            database != current_database()\n            OR nodename != 'localhost'\n            OR username != CURRENT_USER\n            OR nodeport != inet_server_port() \n        THEN\n            format('host=%s port=%s dbname=%s user=%s', nodename, nodeport, database, username)\n        END AS connstr\n    FROM\n        cron.job\n),\ncte_chain AS (\n    INSERT INTO timetable.chain (chain_id, chain_name, run_at, live)\n        SELECT \n            cron_id, COALESCE(jobname, 'cronjob' || cron_id), schedule, active\n        FROM\n            cron_chain\n),\ncte_tasks AS (\n    INSERT INTO timetable.task (chain_id, task_order, kind, command, database_connection)\n        SELECT\n            cron_id, 1, 'SQL', command, connstr\n        FROM\n            cron_chain\n        RETURNING\n            chain_id, task_id\n)\nSELECT * FROM cte_tasks;\n</code></pre>"},{"location":"migration/#migrate-jobs-from-pgagent-to-pg_timetable","title":"Migrate jobs from pgAgent to pg_timetable","text":"<p>To migrate jobs from pgAgent, please use this script. pgAgent doesn't have concept of PROGRAM task, thus to emulate BATCH steps, pg_timetable will execute them inside the shell. You may change the shell by editing cte_shell CTE clause.</p> <pre><code>CREATE OR REPLACE FUNCTION bool_array_to_cron(bool[], start_with int4 DEFAULT 0) RETURNS TEXT AS\n$$\nWITH u AS (\n    SELECT unnest($1) e, generate_series($2, array_length($1, 1)-1+$2) AS i \n)\nSELECT COALESCE(string_agg(i::text, ','), '*') FROM u WHERE e\n$$\nLANGUAGE sql;\n\n\nWITH\ncte_shell(shell, cmd_param) AS (\n    VALUES ('sh', '-c') -- set the shell you want to use for batch steps, e.g. \"pwsh -c\", \"cmd /C\"\n),\npga_schedule AS (\n    SELECT\n        s.jscjobid,\n        s.jscname,\n        format('%s %s %s %s %s', \n            bool_array_to_cron(s.jscminutes), \n            bool_array_to_cron(s.jschours), \n            bool_array_to_cron(s.jscmonthdays), \n            bool_array_to_cron(s.jscmonths, 1), \n            bool_array_to_cron(s.jscweekdays, 1)) AS schedule\n    FROM \n        pgagent.pga_schedule s  \n    WHERE s.jscenabled \n            AND now() &lt; COALESCE(s.jscend, 'infinity'::timestamptz)\n            AND now() &gt; s.jscstart\n),\npga_chain AS (\n    SELECT\n        nextval('timetable.chain_chain_id_seq'::regclass) AS chain_id,\n        jobid,\n        format('%s @ %s', jobname, jscname) AS jobname,\n        jobhostagent,\n        jobenabled,\n        schedule\n    FROM\n        pgagent.pga_job JOIN pga_schedule ON jobid = jscjobid\n),\ncte_chain AS (\n    INSERT INTO timetable.chain (chain_id, chain_name, client_name, run_at, live)\n        SELECT \n            chain_id, jobname, jobhostagent, schedule, jobenabled\n        FROM\n            pga_chain\n),\npga_step AS (\n    SELECT \n        c.chain_id,\n        nextval('timetable.task_task_id_seq'::regclass) AS task_id,\n        rank() OVER (ORDER BY jstname) AS jstorder,\n        jstid,\n        jstname,\n        jstenabled,\n        CASE jstkind WHEN 'b' THEN 'PROGRAM' ELSE 'SQL' END AS jstkind,\n        jstcode,\n        COALESCE(\n            NULLIF(jstconnstr, ''), \n            CASE \n                WHEN jstdbname = current_database() THEN NULL\n                WHEN jstdbname &gt; '' THEN 'dbname=' || jstdbname \n            END\n        ) AS jstconnstr,\n        jstonerror != 'f' AS jstignoreerror\n    FROM\n        pga_chain c JOIN pgagent.pga_jobstep js ON c.jobid = js.jstjobid\n),\ncte_tasks AS (\n    INSERT INTO timetable.task(task_id, chain_id, task_name, task_order, kind, command, database_connection)\n        SELECT\n            task_id, chain_id, jstname, jstorder, jstkind::timetable.command_kind, \n            CASE jstkind WHEN 'SQL' THEN jstcode ELSE sh.shell END,\n            jstconnstr\n        FROM\n            pga_step, cte_shell sh\n),\ncte_parameters AS (\n    INSERT INTO timetable.parameter (task_id, order_id, value)\n        SELECT \n            task_id, 1, jsonb_build_array(sh.cmd_param, s.jstcode)\n        FROM\n            pga_step s, cte_shell sh\n        WHERE \n            s.jstkind = 'PROGRAM'\n)\nSELECT * FROM pga_chain;\n</code></pre>"},{"location":"samples/","title":"Samples","text":""},{"location":"samples/#basic","title":"Basic","text":"<p>This sample demonstrates how to create a basic one-step chain with parameters. It uses CTE to directly update the timetable schema tables.</p> <pre><code>SELECT timetable.add_job(\n    job_name            =&gt; 'notify every minute',\n    job_schedule        =&gt; '* * * * *',\n    job_command         =&gt; 'SELECT pg_notify($1, $2)',\n    job_parameters      =&gt; '[ \"TT_CHANNEL\", \"Ahoj from SQL base task\" ]' :: jsonb,\n    job_kind            =&gt; 'SQL'::timetable.command_kind,\n    job_client_name     =&gt; NULL,\n    job_max_instances   =&gt; 1,\n    job_live            =&gt; TRUE,\n    job_self_destruct   =&gt; FALSE,\n    job_ignore_errors   =&gt; TRUE\n) as chain_id;\n</code></pre>"},{"location":"samples/#send-email","title":"Send email","text":"<p>This sample demonstrates how to create an advanced email job. It will check if there are emails to send, will send them and log the status of the command execution. You don't need to setup anything, every parameter can be specified during the chain creation.</p> <pre><code>DO $$\n    -- An example for using the SendMail task.\nDECLARE\n    v_mail_task_id bigint;\n    v_log_task_id bigint;\n    v_chain_id bigint;\nBEGIN\n    -- Get the chain id\n    INSERT INTO timetable.chain (chain_name, max_instances, live) VALUES ('Send Mail', 1, TRUE)\n    RETURNING chain_id INTO v_chain_id;\n\n    -- Add SendMail task\n    INSERT INTO timetable.task (chain_id, task_order, kind, command) \n    SELECT v_chain_id, 10, 'BUILTIN', 'SendMail'\n    RETURNING task_id INTO v_mail_task_id;\n\n    -- Create the parameters for the SensMail task\n        -- \"username\":        The username used for authenticating on the mail server\n        -- \"password\":        The password used for authenticating on the mail server\n        -- \"serverhost\":      The IP address or hostname of the mail server\n        -- \"serverport\":      The port of the mail server\n        -- \"senderaddr\":      The email that will appear as the sender\n        -- \"ccaddr\":          String array of the recipients(Cc) email addresses\n        -- \"bccaddr\":         String array of the recipients(Bcc) email addresses\n        -- \"toaddr\":          String array of the recipients(To) email addresses\n        -- \"subject\":         Subject of the email\n        -- \"attachment\":      String array of the attachments (local file)\n        -- \"attachmentdata\":  Pairs of name and base64-encoded content\n        -- \"msgbody\":         The body of the email\n\n    INSERT INTO timetable.parameter (task_id, order_id, value)\n        VALUES (v_mail_task_id, 1, '{\n                \"username\":     \"user@example.com\",\n                \"password\":     \"password\",\n                \"serverhost\":   \"smtp.example.com\",\n                \"serverport\":   587,\n                \"senderaddr\":   \"user@example.com\",\n                \"ccaddr\":       [\"recipient_cc@example.com\"],\n                \"bccaddr\":      [\"recipient_bcc@example.com\"],\n                \"toaddr\":       [\"recipient@example.com\"],\n                \"subject\":      \"pg_timetable - No Reply\",\n                \"attachment\":   [\"D:\\\\Go stuff\\\\Books\\\\Concurrency in Go.pdf\",\"report.yaml\"],\n                \"attachmentdata\": [{\"name\": \"File.txt\", \"base64data\": \"RmlsZSBDb250ZW50\"}],\n                \"msgbody\":      \"&lt;b&gt;Hello User,&lt;/b&gt; &lt;p&gt;I got some Go books for you enjoy&lt;/p&gt; &lt;i&gt;pg_timetable&lt;/i&gt;!\",\n                \"contenttype\":  \"text/html; charset=UTF-8\"\n                }'::jsonb);\n\n    -- Add Log task and make it the last task using `task_order` column (=30)\n    INSERT INTO timetable.task (chain_id, task_order, kind, command) \n    SELECT v_chain_id, 30, 'BUILTIN', 'Log'\n    RETURNING task_id INTO v_log_task_id;\n\n    -- Add housekeeping task, that will delete sent mail and update parameter for the previous logging task\n    -- Since we're using special add_task() function we don't need to specify the `chain_id`.\n    -- Function will take the same `chain_id` from the parent task, SendMail in this particular case\n    PERFORM timetable.add_task(\n        kind =&gt; 'SQL', \n        parent_id =&gt; v_mail_task_id,\n        command =&gt; format(\n$query$WITH sent_mail(toaddr) AS (DELETE FROM timetable.parameter WHERE task_id = %s RETURNING value-&gt;&gt;'username')\nINSERT INTO timetable.parameter (task_id, order_id, value) \nSELECT %s, 1, to_jsonb('Sent emails to: ' || string_agg(sent_mail.toaddr, ';'))\nFROM sent_mail\nON CONFLICT (task_id, order_id) DO UPDATE SET value = EXCLUDED.value$query$, \n                v_mail_task_id, v_log_task_id\n            ),\n        order_delta =&gt; 10\n    );\n\n-- In the end we should have something like this. Note, that even Log task was created earlier it will be executed later\n-- due to `task_order` column.\n\n-- timetable=&gt; SELECT task_id, chain_id, kind, left(command, 50) FROM timetable.task ORDER BY task_order;  \n--  task_id | chain_id | task_order |  kind   |                             left\n-- ---------+----------+------------+---------+---------------------------------------------------------------\n--       45 |       24 |         10 | BUILTIN | SendMail\n--       47 |       24 |         20 | SQL     | WITH sent_mail(toaddr) AS (DELETE FROM timetable.p\n--       46 |       24 |         30 | BUILTIN | Log\n-- (3 rows)\n\nEND;\n$$\nLANGUAGE PLPGSQL;\n</code></pre>"},{"location":"samples/#download-transform-and-import","title":"Download, Transform and Import","text":"<p>This sample demonstrates how to create enhanced three-step chain with parameters. It uses DO statement to directly update the timetable schema tables.</p> <pre><code>-- Prepare the destination table 'location'\nCREATE TABLE IF NOT EXISTS public.city(\n    city text,\n    lat numeric,\n    lng numeric,\n    country text,\n    iso2 text,\n    admin_name text,\n    capital text,\n    population bigint,\n    population_proper bigint);\n\nGRANT ALL ON public.city TO scheduler;\n\n-- An enhanced example consisting of three tasks:\n-- 1. Download text file from internet using BUILT-IN command\n-- 2. Remove accents (diacritic signs) from letters using PROGRAM command (can be done with `unaccent` PostgreSQL extension) \n-- 3. Import text file as CSV file using BUILT-IN command (can be down with `psql -c /copy`)\nDO $$\nDECLARE\n    v_task_id bigint;\n    v_chain_id bigint;\nBEGIN\n    -- Create the chain with default values executed every minute (NULL == '* * * * *' :: timetable.cron)\n    INSERT INTO timetable.chain (chain_name, live)\n    VALUES ('Download locations and aggregate', TRUE)\n    RETURNING chain_id INTO v_chain_id;\n\n    -- Step 1. Download file from the server\n    -- Create the chain\n    INSERT INTO timetable.task (chain_id, task_order, kind, command, ignore_error)\n    VALUES (v_chain_id, 1, 'BUILTIN', 'Download', TRUE)\n    RETURNING task_id INTO v_task_id;\n\n    -- Create the parameters for the step 1:\n    INSERT INTO timetable.parameter (task_id, order_id, value)\n        VALUES (v_task_id, 1, \n           '{\n                \"workersnum\": 1,\n                \"fileurls\": [\"https://simplemaps.com/static/data/country-cities/mt/mt.csv\"], \n                \"destpath\": \".\"\n            }'::jsonb);\n\n    RAISE NOTICE 'Step 1 completed. Chain added with ID: %; DownloadFile task added with ID: %', v_chain_id, v_task_id;\n\n    -- Step 2. Transform Unicode characters into ASCII\n    -- Create the program task to call 'uconv' and name it 'unaccent'\n    INSERT INTO timetable.task (chain_id, task_order, kind, command, ignore_error, task_name)\n    VALUES (v_chain_id, 2, 'PROGRAM', 'uconv', TRUE, 'unaccent')\n    RETURNING task_id INTO v_task_id;\n\n    -- Create the parameters for the 'unaccent' task. Input and output files in this case\n    -- Under Windows we should call PowerShell instead of \"uconv\" with command:\n    -- Set-content \"orte_ansi.txt\" ((Get-content \"orte.txt\").Normalize(\"FormD\") -replace '\\p{M}', '')\n    INSERT INTO timetable.parameter (task_id, order_id, value)\n        VALUES (v_task_id, 1, '[\"-x\", \"Latin-ASCII\", \"-o\", \"mt_ansi.csv\", \"mt.csv\"]'::jsonb);\n\n    RAISE NOTICE 'Step 2 completed. Unacent task added with ID: %', v_task_id;\n\n    -- Step 3. Import ASCII file to PostgreSQL table using \"CopyFromFile\" built-in command\n    INSERT INTO timetable.task (chain_id, task_order, kind, command)\n        VALUES (v_chain_id, 3, 'BUILTIN', 'CopyFromFile')\n    RETURNING task_id INTO v_task_id;\n\n    -- Add the parameters for the download task. Execute client side COPY to 'location' from 'orte_ansi.txt'\n    INSERT INTO timetable.parameter (task_id, order_id, value)\n        VALUES (v_task_id, 1, '{\"sql\": \"COPY city FROM STDIN (FORMAT csv, HEADER true)\", \"filename\": \"mt_ansi.csv\" }'::jsonb);\n\n    RAISE NOTICE 'Step 3 completed. Import task added with ID: %', v_task_id;\n\n    INSERT INTO timetable.task (chain_id, task_order, kind, command, ignore_error, task_name)\n    VALUES (v_chain_id, 4, 'PROGRAM', 'bash', TRUE, 'remove .csv')\n    RETURNING task_id INTO v_task_id;\n\n    INSERT INTO timetable.parameter (task_id, order_id, value)\n    VALUES (v_task_id, 1, '[\"-c\", \"rm *.csv\"]'::jsonb);\n\n   RAISE NOTICE 'Step 4 completed. Cleanup task added with ID: %', v_task_id;\nEND;\n$$ LANGUAGE PLPGSQL;\n</code></pre>"},{"location":"samples/#run-tasks-in-autonomous-transaction","title":"Run tasks in autonomous transaction","text":"<p>This sample demonstrates how to run special tasks out of chain transaction context. This is useful for special routines and/or  non-transactional operations, e.g. CREATE DATABASE, REINDEX, VACUUM, CREATE TABLESPACE, etc.</p> <pre><code>-- An advanced example showing how to use atutonomous tasks.\n-- This one-task chain will execute test_proc() procedure.\n-- Since procedure will make two commits (after f1() and f2())\n-- we cannot use it as a regular task, because all regular tasks \n-- must be executed in the context of a single chain transaction.\n-- Same rule applies for some other SQL commands, \n-- e.g. CREATE DATABASE, REINDEX, VACUUM, CREATE TABLESPACE, etc.\nCREATE OR REPLACE FUNCTION f (msg TEXT) RETURNS void AS $$\nBEGIN \n    RAISE notice '%', msg; \nEND;\n$$ LANGUAGE PLPGSQL;\n\nCREATE OR REPLACE PROCEDURE test_proc () AS $$\nBEGIN\n    PERFORM f('hey 1');\n    COMMIT;\n    PERFORM f('hey 2');\n    COMMIT;\nEND;\n$$\nLANGUAGE PLPGSQL;\n\nWITH\n    cte_chain (v_chain_id) AS (\n        INSERT INTO timetable.chain (chain_name, run_at, max_instances, live, self_destruct) \n        VALUES (\n            'call proc() every 10 sec', -- chain_name, \n            '@every 10 seconds',        -- run_at,\n            1,     -- max_instances, \n            TRUE,  -- live, \n            FALSE -- self_destruct\n        ) RETURNING chain_id\n    ),\n    cte_task(v_task_id) AS (\n        INSERT INTO timetable.task (chain_id, task_order, kind, command, ignore_error, autonomous)\n        SELECT v_chain_id, 10, 'SQL', 'CALL test_proc()', TRUE, TRUE\n        FROM cte_chain\n        RETURNING task_id\n    )\nSELECT v_chain_id, v_task_id FROM cte_task, cte_chain;\n</code></pre>"},{"location":"samples/#shutdown-the-scheduler-and-terminate-the-session","title":"Shutdown the scheduler and terminate the session","text":"<p>This sample demonstrates how to shutdown the scheduler using special built-in task. This can be used to control  maintenance windows, to restart the scheduler for update purposes, or to stop session before the database should be  dropped.</p> <pre><code>-- This one-task chain (aka job) will terminate pg_timetable session.\n-- This is useful for maintaining purposes or before database being destroyed.\n-- One should take care of restarting pg_timetable if needed.\n\nSELECT timetable.add_job (\n    job_name     =&gt; 'Shutdown pg_timetable session on schedule',\n    job_schedule =&gt; '* * 1 * *',\n    job_command  =&gt; 'Shutdown',\n    job_kind     =&gt; 'BUILTIN'\n);\n</code></pre>"},{"location":"samples/#access-previous-task-result-code-and-output-from-the-next-task","title":"Access previous task result code and output from the next task","text":"<p>This sample demonstrates how to check the result code and output of a previous task. If the last task failed,  that is possible only if ignore_error boolean = true is set for that task. Otherwise, a scheduler will  stop the chain. This sample shows how to calculate failed, successful, and the total number of tasks executed.  Based on these values, we can calculate the success ratio.</p> <pre><code>WITH \n    cte_chain (v_chain_id) AS ( -- let's create a new chain and add tasks to it later\n        INSERT INTO timetable.chain (chain_name, run_at, max_instances, live) \n        VALUES ('many tasks', '* * * * *', 1, true)\n        RETURNING chain_id\n    ),\n    cte_tasks(v_task_id) AS ( -- now we'll add 500 tasks to the chain, some of them will fail\n        INSERT INTO timetable.task (chain_id, task_order, kind, command, ignore_error)\n        SELECT v_chain_id, g.s, 'SQL', 'SELECT 1.0 / round(random())::int4;', true\n        FROM cte_chain, generate_series(1, 500) AS g(s)\n        RETURNING task_id\n    ),\n    report_task(v_task_id) AS ( -- and the last reporting task will calculate the statistic\n        INSERT INTO timetable.task (chain_id, task_order, kind, command)\n        SELECT v_chain_id, 501, 'SQL', $CMD$DO\n$$\nDECLARE\n    s TEXT;\nBEGIN\n    WITH report AS (\n        SELECT \n        count(*) FILTER (WHERE returncode = 0) AS success,\n        count(*) FILTER (WHERE returncode != 0) AS fail,\n        count(*) AS total\n        FROM timetable.execution_log \n        WHERE chain_id = current_setting('pg_timetable.current_chain_id')::bigint\n          AND txid = txid_current()\n    )\n    SELECT 'Tasks executed:' || total || \n         '; succeeded: ' || success || \n         '; failed: ' || fail || \n         '; ratio: ' || 100.0*success/GREATEST(total,1)\n    INTO s\n    FROM report;\n    RAISE NOTICE '%', s;\nEND;\n$$\n$CMD$\n        FROM cte_chain\n        RETURNING task_id\n    )\nSELECT v_chain_id FROM cte_chain\n</code></pre>"}]}